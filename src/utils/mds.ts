export function normalizeWeights(vals:number[]):number[]{const s=vals.reduce((a,b)=>a+b,0);return s===0?vals.map(()=>1/vals.length):vals.map(x=>x/s)}export function applyReverse(perf:number[][],rev:boolean[]):number[][]{const n=perf.length,m=perf[0].length;const out=Array.from({length:n},()=>Array(m).fill(0));for(let i=0;i<n;i++)for(let j=0;j<m;j++)out[i][j]=rev[j]?(6-perf[i][j]):perf[i][j];return out}export function weightedDistances(perf:number[][],w:number[]):number[][]{const n=perf.length,m=perf[0].length;const D=Array.from({length:n},()=>Array(n).fill(0));for(let i=0;i<n;i++)for(let k=i+1;k<n;k++){let s=0;for(let j=0;j<m;j++){const d=perf[i][j]-perf[k][j];s+=w[j]*d*d}const d=Math.sqrt(s);D[i][k]=d;D[k][i]=d}return D}function matMul(A:number[][],B:number[][]):number[][]{const r=A.length,c=B[0].length,t=B.length;const R=Array.from({length:r},()=>Array(c).fill(0));for(let i=0;i<r;i++)for(let k=0;k<c;k++){let s=0;for(let j=0;j<t;j++)s+=A[i][j]*B[j][k];R[i][k]=s}return R}function matVec(A:number[][],v:number[]):number[]{const r=A.length,c=A[0].length;const out=Array(r).fill(0);for(let i=0;i<r;i++){let s=0;for(let j=0;j<c;j++)s+=A[i][j]*v[j];out[i]=s}return out}function dot(a:number[],b:number[]):number{return a.reduce((s,x,i)=>s+x*b[i],0)}function norm(a:number[]):number{return Math.sqrt(dot(a,a))}export function classicalMDS(D:number[][],d:number):number[][]{const n=D.length;const d2=D.map(r=>r.map(x=>x*x));const J=Array.from({length:n},(_,i)=>Array.from({length:n},(_,k)=>(i===k?1:0)-1/n));const Jd=matMul(J,d2);let B=matMul(Jd,J).map(row=>row.map(x=>-0.5*x));const U:number[][]=Array.from({length:n},()=>[]);const L:number[]=[];for(let k=0;k<d;k++){let v: number[] = Array.from({ length: n }, (_, i) => i % 2 === 0 ? 1 : -1);for(let it=0;it<100;it++){const Mv=matVec(B,v);const nv=norm(Mv);if(nv<1e-10)break;v=Mv.map(x=>x/nv)}const lambda=dot(v,matVec(B,v));for(let i=0;i<n;i++)U[i][k]=v[i];L[k]=lambda;for(let i=0;i<n;i++)for(let j=0;j<n;j++)B[i][j]-=lambda*v[i]*v[j]}const X=Array.from({length:n},()=>Array(d).fill(0));for(let i=0;i<n;i++)for(let k=0;k<d;k++){const lk=L[k]>0?Math.sqrt(L[k]):0;X[i][k]=U[i][k]*lk}return X}export function pca2(perf:number[][]){const n=perf.length,m=perf[0].length;const means=Array(m).fill(0),st=Array(m).fill(0);for(let j=0;j<m;j++){for(let i=0;i<n;i++)means[j]+=perf[i][j];means[j]/=n;for(let i=0;i<n;i++)st[j]+=Math.pow(perf[i][j]-means[j],2);st[j]=Math.sqrt(st[j]/(n-1))||1e-9}const Z=Array.from({length:n},(_,i)=>Array.from({length:m},(_,j)=>(perf[i][j]-means[j])/st[j]));const C=Array.from({length:n},()=>Array(n).fill(0));for(let a=0;a<n;a++)for(let b=a;b<n;b++){let s=0;for(let j=0;j<m;j++)s+=Z[a][j]*Z[b][j];s/=(m-1);C[a][b]=s;C[b][a]=s}return classicalMDS(C,2)}
